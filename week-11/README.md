## Ini adalah copy dari 1806141151_Christopher_week_11.md
# Week 11 Log
## Tanggal : 27 November 2020
### Apa yang saya pelajari :
Pada minggu ini, saya pertama belajar mengenai **background processes**. Dalam sebuah bash shell, cara paling mudah untuk menjalankan suatu process sebagai background process adalah dengan menambahkan "&" di belakang sebuah command (`<command> &`). Tidak seperti foreground process, background process yang dibuat seperti tidak akan ditunggu eksekusinya oleh terminal, tetapi karena masih terhubung dengan 1 terminal, kalau ada output process tersebut akan mengeluarkan outputnya di stdout milik terminalnya (tetapi, background process tidak bisa membaca dari stdin). Lalu, karena process ini masih terhubung dengan suatu terminal, bila terminalnya dimatikan atau dikirim signal seperti SIGTERM atau SIGKILL, process tersebut juga akan dimatikan atau mendapatkan signal yang sama dengan controlling terminalnya.

Kemudian, kita bisa membuat background process yang sifatnya ter-detach dari sebuah controlling terminal dengan `disown <job_id>` (diasumsikan sudah ada background processnya terlebih dahulu, dan angka yang muncul di luar [] setelah membuat background process dapat dijadikan input disown). Disown akan mengeluarkan sebuah process dari job list terminal aslinya, sehingga jika controlling terminal aslinya (sebelum di disown) mendapat signal (misalnya SIGHUP), signalnya tidak akan diteruskan ke process tersebut. Untuk eksekusinya, process ini akan berjalan di background, tetapi akan gagal jika mencoba untuk menulis ke stdout jika terminal aslinya sudah tidak ada atau membaca stdin. Untuk membuat process (bisa background/foreground) yang imun terhadap SIGHUP (signal untuk hang-up), bisa digunakan `nohup <command>`. nohup secara default me-redirect outputnya ke file nohup.out, dan bersifat detached dengan controlling terminal juga.

Setelah itu, saya juga belajar mengenai **process groups** dan **session**. **Process group(s)**, menurut definisi dari buku TPLI, adalah sekumpulan processes yang berjalan dengan process group ID (PGID) yang sama (atau pada dasarnya, sebuah kelompok process yang sedang berjalan). Di tingkat yang lebih tinggi lagi, **session(s)** adalah kumpulan dari beberapa process groups. Pada sekumpulan process, bila Session ID (SID) mereka sama, artinya mereka punya 1 controlling terminal yang sama. Baik process groups maupun sessions memiliki leader (process group leader dan session leader), yang berarti process yang pertama kali memulai process group atau session tersebut.

Melanjutkan pembahasan mengenai background processes, saya juga belajar mengenai **daemons** dan perbedaannya dengan background process biasa. Daemons adalah semacam background process yang tidak memiliki controlling terminal, semua file descriptornya tertutup, dan umumnya memiliki lifespan yang cukup panjang. Ketika sebuah daemon dibuat, daemon tersebut memiliki process group id dan session id yang baru karena cara daemon dibuat. Untuk eksekusi awalnya, sebuah process yang mau menghasilkan sebuah daemon process akan melakukan fork() dan men-terminate parent dari process baru tersebut. Process yang baru tersebut akan melakukan set_sid(), atau men-set sid baru (pada dasarnya, membuat session yang baru), dengan tujuan untuk memutuskan hubungan dengan controlling terminal manapun. Kemudian, process tersebut memanggil fork() lagi untuk memastikan process akhir yang akan menjadi daemon tidak akan pernah mendapat controlling terminal lagi, dan process yang memanggil fork() tadi kemudian memanggil exit() untuk dirinya sendiri. Salah satu konvensi untuk penamaan daemons adalah menambahkan "d" di belakang nama processnya, misalnya httpd (karena konvensi, tidak wajib dilakukan, misalnya pada cron daemon). Sejauh ini, saya baru menemukan cara tidak 100% akurat untuk membedakan antara process biasa dengan daemon, yaitu dengan menggunakan ps -aux dan melihat kolom TTY (Telecommunication TYpewriter), yang menunjukkan controlling terminalnya. Jika kolom tersebut diisi dengan "?", maka process tersebut bisa jadi sebuah daemon, tetapi bisa juga merupakan process yang di disown ataupun dihasilkan dengan nohup.

Terakhir, saya belajar sedikit mengenai command **logger**. logger adalah command untuk menuliskan log di /var/log/syslog. Syntax logger kurang lebih seperti ini : `logger "Msg to log"`. Untuk membaca log terakhir, kita bisa menggunakan tail -1 var/log/syslog. Satu hal yang saya temukan saat mencoba menggunakan logger di WSL adalah kadang kita perlu menyalakan rsyslog service dengan command `sudo service rsyslog start`. Kalau rsyslog tidak berjalan, maka tidak ada log yang ditulis di /var/log/syslog (dan kalau belum ada filenya, tidak akan ada /var/log/syslog).

### Apa yang belum saya pahami :
Saya masih belum mengerti apakah ada cara untuk membedakan antara daemon dengan process lain (termasuk yang di disown atau dibuat dengan nohup). Cara melihat kolom TTY tadi, seperti yang saya jelaskan, tidak menjamin bahwa process tersebut adalah daemon, melainkan bisa juga adalah background process yang controlling terminalnya sudah dihapus dan masih berjalan (misalnya karena disown atau nohup). Saya berharap dalam waktu dekat saya bisa menemukan jawaban untuk permasalahan ini. Untuk sementara, saya belum menemukan cara pasti membedakan process biasa dengan daemon tanpa melihat source codenya, terutama di Ubuntu 18.04, karena PPID dari daemon proses adalah systemd daemon, bukan init lagi.

## Tanggal : 30 November 2020
### Apa yang saya pelajari :
Hari ini, saya pertama mulai dengan mempelajari **cron**, sebuah daemon yang berfungsi untuk menjalankan jobs-jobs tertentu pada waktu yang kita spesifikasikan. Untuk menambah maupun mengurangi jobs yang akan dikerjakan, kita perlu mengubah file konfigurasinya yang bisa dibuka dengan crontab -e (untuk current user saja, dan saat menjalankan juga hanya memiliki privilege user saja), dan untuk root user bisa dengan sudo crontab -e. Setiap user memiliki setting cron masing-masing, dan apa yang mereka bisa kerjakan juga terbatasi oleh privilege mereka (misalnya, non-root user tidak bisa menjalankan jobs yang membutuhkan sudo karena cron juga tidak mem-prompt user untuk memasukkan password). Untuk syntax sebuah job : `minute hour dayOfTheMonth month dayOfTheWeek <command>`. Untuk semua bagian waktu, kita bisa mengisinya dengan angka (atau * kalau tidak peduli bagian waktu tersebut, dan kalau diisi * semua, maka job akan dieksekusi setiap menit), ataupun bisa diganti semua dengan cara menuliskan jangka waktu eksekusi, misalnya @hourly untuk setiap jam. Sebagai tambahan, di WSL (mungkin di WSL saya saja), cron tidak berjalan by default, jadi perlu dijalankan dahulu dengan `sudo cron`.

Lalu, saya juga belajar mengenai proses **re-initialization sebuah daemon** dengan memanfaatkan SIGHUP. Sepemahaman saya, karena daemon tidak terhubung dengan controlling terminal, SIGHUP tidak akan diteruskan ke daemon saat SIGHUP diberikan ke sebuah controlling terminal kecuali secara eksplisit kita berikan SIGHUP sendiri ke processnya, sehingga pada dasarnya daemon memiliki 1 signal lagi yang bisa dimanfaatkan (di trap dan handle). Re-initialization yang umum dilakukan dengan membaca ulang file konfigurasinya, tetapi ada beberapa brute force workaround yang bisa dilakukan, misalnya mensimulasikan re-initialization dengan menggunakan setjmp dan longjmp, seperti yang saya lakukan untuk nomor 5 WS minggu ini.

### Apa yang belum saya pahami :
Saya sudah semakin yakin dengan kesimpulan saya bahwa sulit sekali (mungkin di beberapa kasus tidak mungkin) untuk membedakan process biasa (termasuk daemon-like seperti yang dibuat dengan disown atau nohup) dengan daemon process karena masalah PPID dan TTY juga kadang karakteristiknya bercampur satu sama lain, tetapi saya masih ada keraguan juga tentang jawaban saya ini. Selain itu, saya juga masih belum 100% paham mengenai cara membuat daemon membaca ulang konfigurasinya, dan apa saja konfigurasi dari sebuah daemon.
