## Ini adalah copy dari 1806141151_Christopher_week_11.md
# Week 11 Log
## Tanggal : 27 November 2020
### Apa yang saya pelajari :
Pada minggu ini, saya pertama belajar mengenai **background processes**. Dalam sebuah bash shell, cara paling mudah untuk menjalankan suatu process sebagai background process adalah dengan menambahkan "&" di belakang sebuah command (`<command> &`). Tidak seperti foreground process, background process yang dibuat seperti tidak akan ditunggu eksekusinya oleh terminal, tetapi karena masih terhubung dengan 1 terminal, kalau ada output process tersebut akan mengeluarkan outputnya di stdout milik terminalnya (tetapi, background process tidak bisa membaca dari stdin). Lalu, karena process ini masih terhubung dengan suatu terminal, bila terminalnya dimatikan atau dikirim signal seperti SIGTERM atau SIGKILL, process tersebut juga akan dimatikan atau mendapatkan signal yang sama dengan controlling terminalnya.

Kemudian, kita bisa membuat background process yang sifatnya ter-detach dari sebuah controlling terminal dengan `disown <job_id>` (diasumsikan sudah ada background processnya terlebih dahulu, dan angka yang muncul di luar [] setelah membuat background process dapat dijadikan input disown). Disown akan mengeluarkan sebuah process dari job list terminal aslinya, sehingga jika controlling terminal aslinya (sebelum di disown) mendapat signal (misalnya SIGHUP), signalnya tidak akan diteruskan ke process tersebut. Untuk eksekusinya, process ini akan berjalan di background, tetapi akan gagal jika mencoba untuk menulis ke stdout jika terminal aslinya sudah tidak ada atau membaca stdin. Untuk membuat process (bisa background/foreground) yang imun terhadap SIGHUP (signal untuk hang-up), bisa digunakan `nohup <command>`. nohup secara default me-redirect outputnya ke file nohup.out, dan bersifat detached dengan controlling terminal juga.

Setelah itu, saya juga belajar mengenai **process groups** dan **session**. **Process group(s)**, menurut definisi dari buku TPLI, adalah sekumpulan processes yang berjalan dengan process group ID (PGID) yang sama (atau pada dasarnya, sebuah kelompok process yang sedang berjalan). Di tingkat yang lebih tinggi lagi, **session(s)** adalah kumpulan dari beberapa process groups. Pada sekumpulan process, bila Session ID (SID) mereka sama, artinya mereka punya 1 controlling terminal yang sama. Baik process groups maupun sessions memiliki leader (process group leader dan session leader), yang berarti process yang pertama kali memulai process group atau session tersebut.

Melanjutkan pembahasan mengenai background processes, saya juga belajar mengenai **daemons** dan perbedaannya dengan background process biasa. Daemons adalah semacam background process yang tidak memiliki controlling terminal, semua file descriptornya tertutup, dan umumnya memiliki lifespan yang cukup panjang. Ketika sebuah daemon dibuat, daemon tersebut memiliki process group id dan session id yang baru karena cara daemon dibuat. Untuk eksekusi awalnya, sebuah process yang mau menghasilkan sebuah daemon process akan melakukan fork() dan men-terminate parent dari process baru tersebut. Process yang baru tersebut akan melakukan set_sid(), atau men-set sid baru (pada dasarnya, membuat session yang baru), dengan tujuan untuk memutuskan hubungan dengan controlling terminal manapun. Kemudian, process tersebut memanggil fork() lagi untuk memastikan process akhir yang akan menjadi daemon tidak akan pernah mendapat controlling terminal lagi, dan process yang memanggil fork() tadi kemudian memanggil exit() untuk dirinya sendiri. Salah satu konvensi untuk penamaan daemons adalah menambahkan "d" di belakang nama processnya, misalnya httpd (karena konvensi, tidak wajib dilakukan, misalnya pada cron daemon). Sejauh ini, saya baru menemukan cara tidak 100% akurat untuk membedakan antara process biasa dengan daemon, yaitu dengan menggunakan ps -aux dan melihat kolom TTY (Telecommunication TYpewriter), yang menunjukkan controlling terminalnya. Jika kolom tersebut diisi dengan "?", maka process tersebut bisa jadi sebuah daemon, tetapi bisa juga merupakan process yang di disown ataupun dihasilkan dengan nohup.

Terakhir, saya belajar sedikit mengenai command **logger**. logger adalah command untuk menuliskan log di /var/log/syslog. Syntax logger kurang lebih seperti ini : `logger "Msg to log"`. Untuk membaca log terakhir, kita bisa menggunakan tail -1 var/log/syslog. Satu hal yang saya temukan saat mencoba menggunakan logger di WSL adalah kadang kita perlu menyalakan rsyslog service dengan command `sudo service rsyslog start`. Kalau rsyslog tidak berjalan, maka tidak ada log yang ditulis di /var/log/syslog (dan kalau belum ada filenya, tidak akan ada /var/log/syslog).

### Apa yang belum saya pahami :
Saya masih belum mengerti apakah ada cara untuk membedakan antara daemon dengan process lain (termasuk yang di disown atau dibuat dengan nohup). Cara melihat kolom TTY tadi, seperti yang saya jelaskan, tidak menjamin bahwa process tersebut adalah daemon, melainkan bisa juga adalah background process yang controlling terminalnya sudah dihapus dan masih berjalan (misalnya karena disown atau nohup). Saya berharap dalam waktu dekat saya bisa menemukan jawaban untuk permasalahan ini. Untuk sementara, saya belum menemukan cara pasti membedakan process biasa dengan daemon tanpa melihat source codenya, terutama di Ubuntu 18.04, karena PPID dari daemon proses adalah systemd daemon, bukan init lagi.
