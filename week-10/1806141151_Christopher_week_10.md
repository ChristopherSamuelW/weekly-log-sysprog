# Week 10 Log
## Tanggal : 20 November 2020
### Apa yang saya pelajari :
Pertama, dari pre-test saya belajar lagi mengenai **Signals**. Sebelumnya, signals memang sudah pernah dibahas, terutama di bagian processes (SIGCHLD). Pada dasarnya, signals adalah semacam cara komunikasi antar process, dan signals pada umumnya bisa di-trap atau di-handle, block, maupun di ignore oleh proses yang menerimanya. Cara mengirimkan signal adalah dengan command kill, yang memiliki beberapa options yang bisa dipakai, misalnya `kill -9 -1` untuk mematikan semua process yang bisa dimatikan dan `kill -s TERM (PID)` untuk mengirimkan SIGTERM ke process yang memiliki PID tersebut (SIGTERM sendiri adalah sinyal untuk *clean shutdown*, atau pada dasarnya shutdown secara aman).

Ada beberapa jenis Signals, dan salah satunya adalah **Shutdown Signals**. Seperti yang sudah saya bahas di atas, signal seperti SIGTERM, SIGKILL dan SIGINT masih tergolong ke dalam shutdown signals, walaupun implementasinya berbeda-beda, dan sejauh ini saya baru memahami ketiga signals tersebut. SIGTERM, sesuai yang saya jelaskan, merupakan signal yang dikirimkan ke suatu process ketika process tersebut mau di-terminate secara aman atau biasa. Di lain sisi, SIGINT merupakan signal yang dikirimkan ketika ada interrupt di tengah-tengah process, biasanya oleh user (misalnya saat ada process berjalan lalu kita interrupt dengan Ctrl+C atau keyboard interrupt), dan dapat dianggap sebagai *ungraceful* shutdown. Terakhir, SIGKILL merupakan semacam *last resort* dari shutdown signals. SIGKILL sendiri cukup unik, karena SIGKILL tidak dapat di-trap sama sekali oleh process manapun, sesuai dengan posisinya sebagai last resort shutdown signal (kalau seandainya SIGKILL bisa di trap, bisa saja kernel mau mengirimkan SIGKILL, tetapi karena bisa di-handle, process yang ditarget tidak akan pernah diterminasi).

Lalu, dalam mengerjakan WS, selain menggunakan basic logic untuk beberapa soal, saya juga mulai kembali lagi menggunakan **awk** dan **sed**. Pada WS sebelumnya, saya menggunakan command awk untuk mendapatkan semua user yang terdaftar dalam system, dan saya iterasikan hasilnya untuk membuat .tar.gz backup dari setiap /home user dan membuat .ssh dir dalam setiap /home user juga. Pada WS ini, saya lebih menggunakan kapabilitasnya untuk regex matching dan *associative array* atau yang biasa kita kenal dengan Map data structure. Syntax umum awk adalah sebagai berikut:  
`awk 'VARIABLE comparison_operator /pattern/ { command1; command2; ...; commandN; }'`  
VARIABLE adalah variable yang mau kita match dengan pattern, kemudian comparison_operator bisa berupa ~ (lakukan command-command selanjutnya jika match) atau ~! (lakukan command-command selanjutnya bila tidak match). Lalu, pattern di sini sesuai yang saya sebut adalah pattern yang mengikuti format regex atau regular expression, sehingga hal-hal seperti start of line dan end of line juga valid di sini sebagai bagian pattern dan akan dikenali oleh awk.

Dalam awk, kalau kita membaca sebuah string yang memiliki beberapa baris, awk akan otomatis meng-iterate per baris dan melakukan command lain sesuai keinginan kita sesuai hasil baris tersebut (kalau dengan regex, hanya ketika match), dan dalam commandnya, kita bisa me-refer 1 baris dengan $0. Lalu, awk juga memiliki fungsi split, mirip dengan fungsi split() di Python, lengkap dengan delimiter untuk splittingnya. Syntaxnya kurang lebih seperti berikut:  
`split(SOURCE, DEST_VAR, DELIMITER)`  
di mana SOURCE adalah String var yang mau di split, DEST_VAR adalah tempat penyimpanan variable yang sudah di split (sebagai sebuah array), dan DELIMITER adalah delimiter yang akan digunakan saat melakukan split. Untuk associative array di awk, perbedaan utamanya dengan Map yang biasa kita gunakan adalah kita tidak perlu menginisiasi sebuah entry / key value pairs di associative array awk; kita bisa langsung memanggil asal sebuah key (biasanya langsung diberi 0 kalau belum pernah diubah), dan saya manfaatkan ini untuk mencegah duplicate lines di WS nomor 2, beserta dengan if else clause dalam awk.

Kemudian, tool sed saya gunakan ketika saya mau langsung mengganti sebuah matching pattern dengan pattern lainnya, yang berguna terutama untuk mengerjakan WS nomor 3. sed, atau stream editor, umumnya digunakan sebagai regex matcher juga, tetapi bisa digunakan untuk mengubah isi file tanpa perlu explicit output redirection dengan salah satu optionsnya. Biasanya, kita menggunakan regex dengan struktur berikut kalau mau langsung melihat hasilnya:  
`sed 's/match_pattern/replacement_pattern/optional_flags'`  
di mana command untuk melakukan match & replace, match_pattern adalah pattern yang mau dicari, replacement_pattern adalah pattern yang akan menggantikan setiap instace match_pattern yang match dari string, dan optional_flags bisa kita kosongkan atau isi dengan beberapa flags untuk berbagai macam hal, misalnya mem-print pattern baru jika ada match. Selain itu, sed juga bisa menggunakan capture groups seperti regex pada umumnya, namun sepertinya sangat terbatas kalau dibandingkan dengan gawk atau perl (saya menggunakan semacam pattern matching untuk mengerjakan nomor 2, dengan memanggil hasil capturenya dengan \1 di bagian replacement_pattern setelah match).

Terakhir, dari mengerjakan WS nomor 3, saya juga dikenalkan dengan **beberapa fungsi linux** lainnya, seperti lshw (biasanya sudo lshw) untuk me-list semua hardware, lsblk untuk me-list semua block device, dan vmstat untuk melihat statistik memory saat ini. Selain itu, secara tidak sengaja, saya juga mempelejari beberapa **perbedaan yang cukup krusial antara WSL 1 dengan WSL 2** (setidaknya dalam mengerjakan nomor 3 di WS minggu ini) : yaitu WSL 1 tidak bisa menjalankan vmtstat karena tidak ada /proc/vmstat, dan tidak bisa menjalankan lsblk karena tidak ada /sys/dev/block, sementara WSL 2 bisa menjalankan kedua command ini tanpa masalah.

### Apa yang belum saya pahami :
Sejauh ini, saya belum ada masalah dalam memahami, tetapi saya sadar saya masih belum 100% bisa memanfaatkan sed dan awk semaksimal mungkin, dan masih ada materi mengenai signals yang perlu saya pelajari lagi, terutama di ranah shutdown signals.

## Tanggal : 23 November 2020
### Apa yang saya pelajari :
Setelah mengerjakan WS minggu ini, saya mendapatkan pemahaman dan informasi tambahan juga mengenai signals. Salah satu hal yang saya pelajari adalah bila kita mencoba mengirimkan signal yang sama ke suatu process tanpa interupsi dalam bentuk apapun (dalam flow kill command diberikan berturut-turut), maka hanya akan ada 1 instance signal tersebut yang dikirimkan. Dijelaskan di man page untuk signal(7) jika beberapa standard signal yang sama jika dibuat dan mau dikirimkan dalam waktu yang hampir bersamaan (ketika signal tersebut masih di block), maka hanya ada 1 instance dari signal tersebut yang akan dikirim pada akhirnya setelah unblocking. Dari pengalaman saya, kalau ada interupsi seperti truth value checking di dalam while loop atau sleep command, signal yang sama tersebut dianggap sebagai 2 signal yang berbeda, dan akan dikirim 2 kali juga.

Selain itu, saya juga baru sadar bahwa ada **2 signals** yang bisa saya gunakan sesuai keperluan secara bebas walaupun default handlingnya adalah termination, yaitu **SIGUSR1** dan **SIGUSR2** (yang saya gunakan juga dalam mengerjakan Kill Dash Nine duet scripting). Saya juga mulai mengimplementasikan beberapa trap pada soal tersebut untuk SIGINT (untuk mencegah masalah tambahan seperti data yang seharusnya dihapus tidak terhapus, dll.), dan juga untuk SIGUSR1 dan SIGUSR2 untuk menimpa default action mereka dan menggunakannya sesuai kebutuhan saya, yaitu untuk berkomunikasi mengenai siapa yang "bernyayi" dalam scripting duet tersebut.

Terakhir, saya memplejari juga mengenai signal yang ternyata cukup berguna, yaitu **SIGQUIT**. Seperti SIGTERM dan SIGKILL, SIGQUIT juga akan menterminasi process tujuannya, tetapi SIGQUIT juga akan menghasilkan sebuah core dump, atau informasi mengenai process mana yang diterminasi dan beberapa informasi yang berhubungan. Di buku TLPI juga dijelaskan bahwa SIGQUIT berguna bila kita menghadapi suatu infinite loop dan ingin melakukan debugging. Lalu, seperti SIGINT, signal ini bisa dikirim dengan menggunakan keyboard, dengan kombinasi key CTRL + \\.

### Apa yang belum saya pahami :
Saya belum kesulitan dalam memahami kegunaan signals yang saya pakai untuk mengerjakan WS minggu ini, tetapi memang secara umum saya masih belum memahami semua jenis signal yang ada. Walaupun begitu, dari pengalaman saya, masih ada 1 pertanyaan yang belum saya temukan jawabannya (saya kurang tahu mau meng-query apa juga ke Google), yaitu mengapa ketika saya melakukan keyboard interrupt untuk menghasilkan SIGQUIT, dumpnya langsung muncul, tetapi saat saya berikan menggunakan kill command, tidak terlihat apa-apa (saat menjalankan duet kill dash nine, tidak terlihat ada interupsi yang jelas di vocalist manapun). Untuk penggunaan sed dan awk, saya sudah mulai terbiasa, tetapi masih perlu latihan juga.
