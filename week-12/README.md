## Ini adalah copy dari 1806141151_Christopher_week_12.md
# Week 12 Log
## Tanggal : 4-5 Desember 2020
### Apa yang saya pelajari :
Minggu ini, saya pertama belajar mengenai **boot process** dari suatu komputer, terutama dengan OS UNIX-based. Ada beberapa terminologi yang sebelumnya sudah pernah saya dengar, tetapi saya tidak 100% mengerti maksudnya apa, seperti:
- Boot PROM / PROM Monitor / BIOS (Basic I/O System) : *persistent code* yang sudah berjalan saat mesin dinyalakan
- Bootloader / Bootstrap : program yang menjalankan kernel
<!-- end of list -->

Secara spesifik, **BIOS** berfungsi untuk melakukan system checkup sebelum melanjutkan booting process. Belakangan ini, BIOS mulai digantikan dengan **Unified Extensible Firmware Interface** atau disingkat **UEFI** (laptop saya juga sudah menggunakan UEFI), karena UEFI bisa mengatasi beberapa keterbatasan yang dihadapi oleh BIOS, seperti lama boot time dan  driver support. Selain itu, karena UEFI biasanya berjalan di 32 bit atau 64 bit mode, UEFI kuat untuk menampilkan sebuah GUI juga untuk mempermudah navigasi, dibandingkan BIOS yang hanya berupa basic CLI saja karena berjalan di 16 bit mode.

Process booting kurang lebih dimulai dengan menjalankan **BIOS / UEFI**. Setelah BIOS / UEFI selesai menjalankan tugasnya, **GRUB** stage 1 akan di load dari **MBR** (512 bytes pertama di disk). Setelah itu, GRUB akan masuk ke stage 1.5, di mana program yang terletak di 30kB pertama dalam disk (yang mengandung file system driver) akan di load. Terakhir, di stage 2, akan ditampilkan menu yang berisi pilihan kernel dalam sebuah partisi yang bisa kita pilih. Setelah kita memilih kernel, ada driver-driver tambahan (disebut modules) yang akan di load dari RAM disk, yang disebut initrd atau initramfs. Selanjutnya, saat kernel sudah selesai menjalankan OS, kernel akan melakukan mounting ROOT file system ke "/", dan dilanjutkan dengan eksekusi init, yang akan menjalankan boot scripts, sebelum process booting berakhir.

Selain BIOS yang mulai digantikan dengan UEFI, MBR juga sekarang mulai digantikan dengan **GPT** atau Global Partitioning Table. Secara umum, GPT lebih baik dibandingkan dengan MBR dalam melakukan partitioning, dan GPT umumnya digunakan bersamaan dengan UEFI. Beberapa kelebihan dari GPT dibandingkan dengan MBR:
- GPT memperbolehkan pembuatan drive partition sebanyak mungkin, walaupun masih dibatasi oleh OS
- GPT menyimpan banyak salinan dari isi partisi dan boot data di berbagai lokasi dalam disk, sehingga masih ada backup kalau data-data tersebut tidak sengaja terhapus atau tertimpa, tidak seperti MBR yang hanya menyimpan data-data tersebut di 1 lokasi saja 
- GPT juga memiliki sistem Cyclic Redundancy Check (CRC) untuk error detection dan correction jika ada corrupted data
<!-- end of list -->

Lalu, saya juga belajar mengenai beberapa pendekatan mengenai **arsitektur kernel**, yang dipecah menjadi Monolithic, Micro-Kernel, dan Hybrid. Berikut adalah pemahaman saya mengenai ketiganya:
- **Monolithic** : kernel dengan arsitektur ini tidak hanya meng-handle bare minimum untuk menjalankan OS, tetapi juga mengurus hal-hal seperti device drivers, sehingga walaupun proses komunikasi dll. cukup cepat, memory yang dimakan juga cukup tinggi. Untuk men-support kinerja dari arsitektur kernel ini, semua process berjalan dalam supervisor mode, sehingga menimbulkan security threat juga.
- **Micro-Kernel** : kernel dengan arsitektur ini hanya mengurus CPU, memory, dan inter-process communication (IPC), atau bare minimum untuk menjalankan OS, sehingga memory yang digunakan juga relatif rendah, terutama jika dibandingkan dengan pendekatan Monolithic. Selain itu, karena ada ada pembagian process yang dijalankan di user dan supervisor mode, pendekatan ini cukup aman. Tetapi, karena implementasinya, waktu access hardware dan komunikasi juga cenderung menjadi lebih lama.
- **Hybrid** : pendekatan ini menggabungkan kedua pendekatan sebelumnya untuk mencapai hasil yang kita inginkan, dan karena pendekatan ini sesuai namanya adalah hybrid, keuntungan dan kerugian dari menggunakan pendekatan arsitektur ini juga merupakan gabungan dari keduanya (tergantung apa yang kita implementasikan).
<!-- end of list -->

Terakhir, saya menerapkan sendiri proses **kernel compilation** sampai me-load kernel yang saya compile tersebut dalam GRUB VBox saya. Sebenarnya, step-step persiapan kompilasi kernel sampai me-load kernel tersebut hingga dikenali GRUB cukup sederhana dan tutorial yang diberikan cukup jelas, namun yang menjadi masalah utama adalah saat kompilasi berlangsung. Proses kompilasi membutuhkan waktu yang cukup lama, terutama jika resource RAM dan processor yang dialokasikan terbatas. Saya mengalokasikan RAM 4GB (dari 8GB RAM saya) dan 2 processor saya untuk kompilasi, dan akhirnya membutuhkan waktu sekitar 2-2.5 jam untuk selesai kompilasi. Selain itu, saya berharap bahwa dengan alokasi RAM dan processor tersebut, saya bisa multitasking dengan tugas lain, namun nyatanya proses kompilasi tersebut sangat berat juga hingga terkadang membuka File Explorer saja membutuhkan >10 detik tanpa response.

### Apa yang belum saya pahami :
Saya mengalami beberapa kali error dalam kompilasi kernel, terutama dengan kernel yang saya download dari kambing.ui.ac.id, dan saya tidak mengerti apa yang menjadi masalah sehingga menimbulkan error-error tersebut. Dalam kompilasi kernel itu, saya sering mendapat error message "segmentation fault", dan beberapa error message lainnya. Anehnya, tanpa saya ganti apapun, ketika saya clean dan make-kpkg ulang, error yang kurang lebih sama (terutama "segmentation fault") muncul di file yang berbeda, sementara sepertinya file yang tadi menimbulkan segmentation fault bisa dicompile dengan sukses. Saat saya mencari solusinya di Google, jawaban-jawaban yang saya temukan umumnya tidak relevan dengan masalah saya, dan akhirnya saya berganti ke kernel dari kernel.org versi terbaru (dan akhirnya saya sukses dengan versi ini).